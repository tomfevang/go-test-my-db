package mcptools

import (
	"context"
	"database/sql"
	"fmt"
	"strings"

	_ "github.com/go-sql-driver/mysql"
	"github.com/modelcontextprotocol/go-sdk/mcp"

	"github.com/tomfevang/go-seed-my-db/internal/generator"
	"github.com/tomfevang/go-seed-my-db/internal/introspect"
)

type generateConfigArgs struct {
	DSN string `json:"dsn,omitempty" jsonschema:"MySQL DSN. Falls back to SEED_DSN env var if omitted."`
}

func registerGenerateConfig(s *mcp.Server) {
	mcp.AddTool(s, &mcp.Tool{
		Name:        "generate_config",
		Description: "Generate a go-seed-my-db.yaml config by introspecting the database schema. Returns the YAML content as text (does not write to disk).",
		Annotations: &mcp.ToolAnnotations{ReadOnlyHint: true},
	}, handleGenerateConfig)
}

func handleGenerateConfig(_ context.Context, _ *mcp.CallToolRequest, args generateConfigArgs) (*mcp.CallToolResult, struct{}, error) {
	dsn := resolveDSN(args.DSN)
	if dsn == "" {
		return errResult("DSN is required"), struct{}{}, nil
	}

	schema := extractSchema(dsn)
	if schema == "" {
		return errResult("could not extract database name from DSN"), struct{}{}, nil
	}

	db, err := sql.Open("mysql", dsn)
	if err != nil {
		return errResult(fmt.Sprintf("connecting: %v", err)), struct{}{}, nil
	}
	defer db.Close()

	if err := db.Ping(); err != nil {
		return errResult(fmt.Sprintf("pinging: %v", err)), struct{}{}, nil
	}

	tableNames, err := introspect.ListTables(db, schema)
	if err != nil {
		return errResult(fmt.Sprintf("listing tables: %v", err)), struct{}{}, nil
	}
	if len(tableNames) == 0 {
		return errResult(fmt.Sprintf("no tables found in schema %s", schema)), struct{}{}, nil
	}

	tables := make([]*introspect.Table, 0, len(tableNames))
	for _, name := range tableNames {
		t, err := introspect.IntrospectTable(db, schema, name)
		if err != nil {
			return errResult(fmt.Sprintf("introspecting %s: %v", name, err)), struct{}{}, nil
		}
		tables = append(tables, t)
	}

	yaml := buildInitYAML(dsn, tables)
	return textResult(yaml), struct{}{}, nil
}

// buildInitYAML generates a starter go-seed-my-db.yaml from introspected tables.
// Duplicated from cmd/init.go to avoid exporting cmd internals.
func buildInitYAML(dsnVal string, tables []*introspect.Table) string {
	var sb strings.Builder

	sb.WriteString("# Generated by: go-seed-my-db init\n")
	sb.WriteString("# Review and uncomment sections as needed.\n\n")

	sb.WriteString("options:\n")
	fmt.Fprintf(&sb, "  dsn: %q\n", redactDSNPassword(dsnVal))
	sb.WriteString("  rows: 1000\n")
	sb.WriteString("  batch_size: 1000\n")
	sb.WriteString("  workers: 4\n")
	sb.WriteString("\n")

	sb.WriteString("tables:\n")
	for _, t := range tables {
		fmt.Fprintf(&sb, "  %s:\n", t.Name)
		sb.WriteString("    # rows: 1000\n")

		var refs []string
		for _, col := range t.Columns {
			if col.FK != nil {
				refs = append(refs, fmt.Sprintf("    #   %s: %s.%s",
					col.Name, col.FK.ReferencedTable, col.FK.ReferencedColumn))
			}
		}
		if len(refs) > 0 {
			sb.WriteString("    # references:\n")
			for _, r := range refs {
				sb.WriteString(r + "\n")
			}
		}

		var colLines []string
		for _, col := range t.Columns {
			if col.IsAutoInc || col.IsGenerated || col.FK != nil {
				continue
			}
			label := generator.NameBasedLabel(col)
			if label != "" {
				colLines = append(colLines,
					fmt.Sprintf("    #   %s: '{{ %s }}'  # detected heuristic", col.Name, label))
			} else if len(col.EnumValues) > 0 {
				vals := col.EnumValues
				if len(vals) > 8 {
					vals = vals[:8]
				}
				colLines = append(colLines,
					fmt.Sprintf("    #   %s:  # enum: [%s]", col.Name, strings.Join(vals, ", ")))
			}
		}
		if len(colLines) > 0 {
			sb.WriteString("    # columns:\n")
			for _, l := range colLines {
				sb.WriteString(l + "\n")
			}
		}

		sb.WriteString("\n")
	}

	sb.WriteString("# tests:\n")
	sb.WriteString("#   - name: example query\n")
	sb.WriteString("#     query: SELECT COUNT(*) FROM ...\n")
	sb.WriteString("#     repeat: 5\n")

	return sb.String()
}

// redactDSNPassword replaces the password portion of a MySQL DSN with ***.
func redactDSNPassword(dsn string) string {
	atIdx := strings.Index(dsn, "@")
	if atIdx == -1 {
		return dsn
	}
	userPass := dsn[:atIdx]
	colonIdx := strings.Index(userPass, ":")
	if colonIdx == -1 {
		return dsn
	}
	return userPass[:colonIdx+1] + "***" + dsn[atIdx:]
}
