package cmd

import (
	"database/sql"
	"fmt"
	"os"
	"strings"

	_ "github.com/go-sql-driver/mysql"
	"github.com/spf13/cobra"

	"github.com/tomfevang/go-seed-my-db/internal/generator"
	"github.com/tomfevang/go-seed-my-db/internal/introspect"
)

var (
	initDSN    string
	initOutput string
	initForce  bool
)

var initCmd = &cobra.Command{
	Use:   "init",
	Short: "Generate a starter config file by introspecting the database",
	Long: `The init command connects to your MySQL database, introspects the schema,
and generates a commented go-seed-my-db.yaml with detected heuristics,
foreign key references, and enum values.`,
	RunE: runInit,
}

func init() {
	initCmd.Flags().StringVar(&initDSN, "dsn", "", "MySQL DSN (required), e.g. user:pass@tcp(localhost:3306)/mydb")
	initCmd.Flags().StringVar(&initOutput, "output", "go-seed-my-db.yaml", "Output file path")
	initCmd.Flags().BoolVar(&initForce, "force", false, "Overwrite output file if it already exists")

	rootCmd.AddCommand(initCmd)
}

func runInit(cmd *cobra.Command, args []string) error {
	dsnVal := initDSN
	if dsnVal == "" {
		if v := os.Getenv("SEED_DSN"); v != "" {
			dsnVal = v
		}
	}
	if dsnVal == "" {
		return fmt.Errorf("DSN is required — set via --dsn flag or SEED_DSN env var")
	}

	// Check output file.
	if !initForce {
		if _, err := os.Stat(initOutput); err == nil {
			return fmt.Errorf("file %s already exists — use --force to overwrite", initOutput)
		}
	}

	schema := extractSchema(dsnVal)
	if schema == "" {
		return fmt.Errorf("could not extract database name from DSN — ensure it ends with /dbname")
	}

	db, err := sql.Open("mysql", dsnVal)
	if err != nil {
		return fmt.Errorf("connecting to MySQL: %w", err)
	}
	defer db.Close()

	if err := db.Ping(); err != nil {
		return fmt.Errorf("pinging MySQL: %w", err)
	}
	fmt.Printf("Connected to %s\n", schema)

	tableNames, err := introspect.ListTables(db, schema)
	if err != nil {
		return err
	}
	if len(tableNames) == 0 {
		return fmt.Errorf("no tables found in schema %s", schema)
	}

	tables := make([]*introspect.Table, 0, len(tableNames))
	for _, name := range tableNames {
		t, err := introspect.IntrospectTable(db, schema, name)
		if err != nil {
			return err
		}
		tables = append(tables, t)
	}

	yaml := buildInitYAML(dsnVal, tables)

	if err := os.WriteFile(initOutput, []byte(yaml), 0644); err != nil {
		return fmt.Errorf("writing %s: %w", initOutput, err)
	}

	fmt.Printf("Generated %s (%d tables)\n", initOutput, len(tables))
	return nil
}

func buildInitYAML(dsnVal string, tables []*introspect.Table) string {
	var sb strings.Builder

	sb.WriteString("# Generated by: go-seed-my-db init\n")
	sb.WriteString("# Review and uncomment sections as needed.\n\n")

	// Options section.
	sb.WriteString("options:\n")
	sb.WriteString(fmt.Sprintf("  dsn: %q\n", redactDSNPassword(dsnVal)))
	sb.WriteString("  rows: 1000\n")
	sb.WriteString("  batch_size: 1000\n")
	sb.WriteString("  workers: 4\n")
	sb.WriteString("\n")

	// Tables section.
	sb.WriteString("tables:\n")
	for _, t := range tables {
		sb.WriteString(fmt.Sprintf("  %s:\n", t.Name))
		sb.WriteString("    # rows: 1000\n")

		// Collect FK references.
		var refs []string
		for _, col := range t.Columns {
			if col.FK != nil {
				refs = append(refs, fmt.Sprintf("    #   %s: %s.%s",
					col.Name, col.FK.ReferencedTable, col.FK.ReferencedColumn))
			}
		}
		if len(refs) > 0 {
			sb.WriteString("    # references:\n")
			for _, r := range refs {
				sb.WriteString(r + "\n")
			}
		}

		// Collect columns with heuristic matches, templates, or enums.
		var colLines []string
		for _, col := range t.Columns {
			if col.IsAutoInc || col.IsGenerated || col.FK != nil {
				continue
			}

			label := generator.NameBasedLabel(col)
			if label != "" {
				colLines = append(colLines,
					fmt.Sprintf("    #   %s: '{{ %s }}'  # detected heuristic", col.Name, label))
			} else if len(col.EnumValues) > 0 {
				vals := col.EnumValues
				if len(vals) > 8 {
					vals = vals[:8]
				}
				colLines = append(colLines,
					fmt.Sprintf("    #   %s:  # enum: [%s]", col.Name, strings.Join(vals, ", ")))
			}
		}
		if len(colLines) > 0 {
			sb.WriteString("    # columns:\n")
			for _, l := range colLines {
				sb.WriteString(l + "\n")
			}
		}

		sb.WriteString("\n")
	}

	// Tests placeholder.
	sb.WriteString("# tests:\n")
	sb.WriteString("#   - name: example query\n")
	sb.WriteString("#     query: SELECT COUNT(*) FROM ...\n")
	sb.WriteString("#     repeat: 5\n")

	return sb.String()
}

// redactDSNPassword replaces the password portion of a MySQL DSN with ***.
// DSN format: user:pass@tcp(host:port)/dbname
func redactDSNPassword(dsn string) string {
	atIdx := strings.Index(dsn, "@")
	if atIdx == -1 {
		return dsn
	}
	userPass := dsn[:atIdx]
	colonIdx := strings.Index(userPass, ":")
	if colonIdx == -1 {
		return dsn
	}
	return userPass[:colonIdx+1] + "***" + dsn[atIdx:]
}
